#1
<# Get-SnykExportCsv.ps1  (Windows PowerShell 5.1)
    Starts a Snyk Export job, polls to completion, and downloads CSVs.
#>

[CmdletBinding()]
param(
  [Parameter(Mandatory=$true)]
  [string]$Token,                               # personal token: "token <value>" ; OAuth: use -AuthType Bearer

  [Parameter(ParameterSetName='Org', Mandatory=$true)]
  [string]$OrgId,

  [Parameter(ParameterSetName='Group', Mandatory=$true)]
  [string]$GroupId,

  [ValidateSet('Issues','issues')] [string]$Dataset = 'issues',
  [string[]]$Columns,

  [hashtable]$Filters,

  [switch]$IncludeDeleted,
  [switch]$IncludeDeactivated,

  [ValidateSet('Token','Bearer')] [string]$AuthType = 'Token',
  [string]$ApiBaseUrl = 'https://api.snyk.io',
  [string]$ApiVersion = '2024-10-15',

  [string]$OutDir,

  [int]$PollSeconds = 6,
  [int]$TimeoutMinutes = 30,

  # date-window helpers to satisfy Snykâ€™s required date filter
  [int]$DateWindowDays = 30,    # default: last 30 days
  [switch]$UseUpdated,          # use updated window instead of introduced
  [switch]$AllTime              # override: export everything since 1970
)

# ----- PS 5.1 compat / hardening -----
$ErrorActionPreference = 'Stop'
$ProgressPreference = 'SilentlyContinue'
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
[void][Reflection.Assembly]::LoadWithPartialName('System.IO.Compression.FileSystem')

function Get-IsoUtc([datetime]$dt) { $dt.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ') }

function New-SnykHeaders {
  param([string]$Token,[string]$AuthType)
  $auth = if ($AuthType -eq 'Bearer') { "bearer $Token" } else { "token $Token" }
  return @{
    'Authorization' = $auth
    'Accept'        = 'application/vnd.api+json'
    'Content-Type'  = 'application/vnd.api+json'
  }
}

function Invoke-SnykGet {
  param([string]$Url,[hashtable]$Headers)
  Write-Verbose "GET $Url"
  Invoke-RestMethod -Method Get -Uri $Url -Headers $Headers
}

function Invoke-SnykPost {
  param([string]$Url,[hashtable]$Headers,[string]$BodyJson)
  Write-Verbose "POST $Url"
  # Use Invoke-WebRequest to capture headers (Location, etc.)
  $resp = Invoke-WebRequest -UseBasicParsing -Method Post -Uri $Url -Headers $Headers -Body $BodyJson
  $obj = $null
  if ($resp.Content -and $resp.Content.Trim().Length -gt 0) {
    try { $obj = $resp.Content | ConvertFrom-Json } catch { }
  }
  return @{ Json=$obj; Headers=$resp.Headers }
}

function Get-ExportBasePath {
  if ($PSCmdlet.ParameterSetName -eq 'Group') { "/rest/groups/$GroupId" } else { "/rest/orgs/$OrgId" }
}

function Parse-IdFromUrl([string]$u) {
  if (-not $u) { return $null }
  try {
    $p = (New-Object System.Uri($u)).AbsolutePath.TrimEnd('/')
  } catch { $p = $u }
  $last = $p.Split('/')[-1]
  if ($last -match '^[\w\-]{6,}$') { return $last } else { return $null }
}

function Find-ExportId {
  param($PostObj, $Headers)
  # 1) links.self (top-level or under data)
  $candidates = @()
  if ($PostObj) {
    if ($PostObj.links -and $PostObj.links.self) { $candidates += $PostObj.links.self }
    if ($PostObj.data) {
      if ($PostObj.data.links -and $PostObj.data.links.self) { $candidates += $PostObj.data.links.self }
      if ($PostObj.data.id) { $candidates += $PostObj.data.id }
      if ($PostObj.id)      { $candidates += $PostObj.id }
    }
    if ($PostObj.id) { $candidates += $PostObj.id }
  }
  # 2) Location header
  if ($Headers -and $Headers.Location) { $candidates += $Headers.Location }
  foreach ($c in $candidates) {
    $id = Parse-IdFromUrl $c
    if ($id) { return $id }
    if ($c -is [string] -and $c -match '^[\w\-]{6,}$') { return $c }
  }
  return $null
}

function Ensure-DateFilter {
  param([hashtable]$Filters,[switch]$UseUpdated,[switch]$AllTime,[int]$DateWindowDays)
  if (-not $Filters) { $Filters = @{} }
  if ($Filters.ContainsKey('introduced') -or $Filters.ContainsKey('updated')) { return $Filters }

  if ($AllTime) {
    $Filters['introduced'] = @{ from='1970-01-01T00:00:00Z'; to= Get-IsoUtc (Get-Date) }
  } elseif ($UseUpdated) {
    $Filters['updated'] = @{ from= Get-IsoUtc ((Get-Date).AddDays(-$DateWindowDays)); to= Get-IsoUtc (Get-Date) }
  } else {
    $Filters['introduced'] = @{ from= Get-IsoUtc ((Get-Date).AddDays(-$DateWindowDays)); to= Get-IsoUtc (Get-Date) }
  }
  return $Filters
}

# ----- build request body -----
if (-not $Columns -or $Columns.Count -eq 0) {
  $Columns = @(
    'ISSUE_SEVERITY_RANK','ISSUE_SEVERITY','SCORE',
    'PROBLEM_TITLE','CVE','CWE',
    'PROJECT_NAME','PROJECT_URL',
    'EXPLOIT_MATURITY','AUTOFIXABLE',
    'FIRST_INTRODUCED','ISSUE_URL','ISSUE_STATUS_INDICATOR','ISSUE_TYPE'
  )
}

$Filters = Ensure-DateFilter -Filters $Filters -UseUpdated:$UseUpdated -AllTime:$AllTime -DateWindowDays $DateWindowDays

$attributes = @{
  dataset = $Dataset.ToLower()
  columns = $Columns
  formats = @('csv')
  filters = $Filters
}

$body = @{ data = @{ type='resource'; attributes=$attributes } }
$bodyJson = ($body | ConvertTo-Json -Depth 8)

# ----- fire export -----
$base = $ApiBaseUrl.TrimEnd('/')
$root = Get-ExportBasePath
$includeParams = @()
if ($IncludeDeleted)     { $includeParams += 'include_deleted=true' }
if ($IncludeDeactivated) { $includeParams += 'include_deactivated=true' }
$qs = @("version=$ApiVersion")
if ($includeParams.Count) { $qs += $includeParams }
$exportStartUrl = "{0}{1}/export?{2}" -f $base, $root, ($qs -join '&')

$headers = New-SnykHeaders -Token $Token -AuthType $AuthType
$start = Invoke-SnykPost -Url $exportStartUrl -Headers $headers -BodyJson $bodyJson

$exportId = Find-ExportId -PostObj $start.Json -Headers $start.Headers
if (-not $exportId) {
  Write-Verbose ("POST JSON: " + ($start.Json | ConvertTo-Json -Depth 10))
  Write-Verbose ("Headers: " + ($start.Headers | Out-String))
  throw "Could not determine export id from response (no links.self, data.id, or Location header)."
}
Write-Host ("Started export id: {0}" -f $exportId)

# ----- poll status (try known patterns) -----
$deadline = (Get-Date).AddMinutes($TimeoutMinutes)

function Try-GetStatus {
  param([string]$Id)
  $candidates = @(
    "{0}{1}/jobs/export/{2}?version={3}" -f $base,$root,$Id,$ApiVersion,
    "{0}{1}/export/jobs/{2}?version={3}" -f $base,$root,$Id,$ApiVersion,
    "{0}{1}/export/{2}?version={3}"      -f $base,$root,$Id,$ApiVersion,
    "{0}{1}/exports/{2}?version={3}"     -f $base,$root,$Id,$ApiVersion
  )
  foreach ($u in $candidates) {
    try {
      $r = Invoke-SnykGet -Url $u -Headers $headers
      # try several shapes for status
      $s = $null
      if ($r.data -and $r.data.attributes -and $r.data.attributes.status) { $s = $r.data.attributes.status }
      elseif ($r.attributes -and $r.attributes.status) { $s = $r.attributes.status }
      elseif ($r.status) { $s = $r.status }
      if ($s) { return @{ Status=$s; Raw=$r; Url=$u } }
    } catch {
      continue
    }
  }
  return $null
}

do {
  Start-Sleep -Seconds $PollSeconds
  $st = Try-GetStatus -Id $exportId
  if (-not $st) { Write-Verbose "Status probe failed; retrying..."; continue }
  $status = $st.Status
  Write-Host ("Status: {0} @ {1:HH:mm:ss}" -f $status, (Get-Date))
  if ($status -match 'FAILED|ERROR') { throw "Export failed. Status: $status" }
} while ($status -notmatch 'COMPLETE|COMPLETED' -and (Get-Date) -lt $deadline)

if ($status -notmatch 'COMPLETE|COMPLETED') { throw "Timeout after $TimeoutMinutes minutes waiting for export to complete." }

# ----- get results (try several shapes) -----
function Try-GetResults {
  param([string]$Id)
  $urls = @(
    "{0}{1}/export/{2}?version={3}"        -f $base,$root,$Id,$ApiVersion,
    "{0}{1}/export/jobs/{2}?version={3}"   -f $base,$root,$Id,$ApiVersion,
    "{0}{1}/exports/{2}?version={3}"       -f $base,$root,$Id,$ApiVersion,
    "{0}{1}/export/{2}/results?version={3}"-f $base,$root,$Id,$ApiVersion
  )
  foreach ($u in $urls) {
    try {
      $r = Invoke-SnykGet -Url $u -Headers $headers
      $results = $null
      if ($r.data -and $r.data.attributes -and $r.data.attributes.results) { $results = $r.data.attributes.results }
      elseif ($r.attributes -and $r.attributes.results) { $results = $r.attributes.results }
      elseif ($r.results) { $results = $r.results }
      if ($results) { return $results }
    } catch { continue }
  }
  return $null
}

$results = Try-GetResults -Id $exportId
if (-not $results) { throw "API returned no results to download (tried multiple endpoints)." }

# ----- output dir -----
if (-not $OutDir) {
  $OutDir = Join-Path -Path (Get-Location) -ChildPath ("SnykExport_{0}" -f (Get-Date -f 'yyyyMMdd_HHmmss'))
}
New-Item -Path $OutDir -ItemType Directory -Force | Out-Null

function Get-ResultUrlAndName {
  param($r)
  $url  = $null; $name = $null
  if ($r.url)       { $url = $r.url }
  elseif ($r.href)  { $url = $r.href }
  elseif ($r.uri)   { $url = $r.uri }
  elseif ($r.location) { $url = $r.location }
  elseif ($r.file -and $r.file.url) { $url = $r.file.url }

  if ($r.filename)      { $name = $r.filename }
  elseif ($r.file -and $r.file.filename) { $name = $r.file.filename }
  elseif ($url)         { $name = [IO.Path]::GetFileName( (New-Object System.Uri($url)).AbsolutePath ) }

  if (-not $url)  { throw "Result item missing a download URL: $($r | ConvertTo-Json -Depth 5)" }
  if (-not $name) { $name = 'snyk-export.csv' }
  @{ Url=$url; Name=$name }
}

$downloaded = @()
foreach ($r in @($results)) {
  $info = Get-ResultUrlAndName -r $r
  $target = Join-Path -Path $OutDir -ChildPath $info.Name
  Write-Host "Downloading $($info.Url) -> $target"
  try {
    Invoke-WebRequest -UseBasicParsing -Uri $info.Url -OutFile $target
  } catch {
    Invoke-WebRequest -UseBasicParsing -Uri $info.Url -OutFile $target -Headers @{ 'Authorization' = $headers.Authorization }
  }
  $downloaded += $target
  if ($target.ToLower().EndsWith('.zip')) {
    $unzippedDir = Join-Path $OutDir ([IO.Path]::GetFileNameWithoutExtension($target))
    if (-not (Test-Path $unzippedDir)) { New-Item -Path $unzippedDir -ItemType Directory | Out-Null }
    [System.IO.Compression.ZipFile]::ExtractToDirectory($target, $unzippedDir, $true)
  }
}

Write-Host "`nDone."
Write-Host ("Output folder: {0}" -f $OutDir)
Write-Host ("Files downloaded:`n - " + ($downloaded -join "`n - "))
