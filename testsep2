<# Snyk Export (PS 5.1-safe)
   - Start export, poll status, download CSVs
   - Works at org or group scope
   - Builds canonical /rest URLs using data.id
#>

[CmdletBinding(DefaultParameterSetName='Org')]
param(
  [Parameter(Mandatory=$true, ParameterSetName='Org')]
  [string]$OrgId,
  [Parameter(Mandatory=$true, ParameterSetName='Group')]
  [string]$GroupId,

  [string]$Token   = $env:SNYK_TOKEN,
  [string]$BaseUrl = "https://api.snyk.io",     # change to https://api.us.snyk.io or https://api.eu.snyk.io if applicable
  [string]$Version = "2025-08-01",

  [ValidateSet('issues','usage')]
  [string]$Dataset = "issues",
  [datetime]$UpdatedFrom = (Get-Date).AddDays(-7),
  [datetime]$UpdatedTo   = (Get-Date),

  [int]$PollSeconds = 10,
  [int]$TimeoutMinutes = 60,
  [string]$OutDir = ".\snyk-export"
)

if (-not $Token) { throw "Provide -Token or set `$env:SNYK_TOKEN." }

# ---------- helpers ----------
function New-JsonTime([datetime]$dt) { $dt.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ") }

function Test-SnykScopeAccess {
  param([string]$Url,[hashtable]$Headers)
  try { Invoke-RestMethod $Url -Headers $Headers -ErrorAction Stop | Out-Null }
  catch { throw "Token cannot read $Url. Fix region ($BaseUrl) or grant 'View reports' on this scope." }
}

function Parse-Status([string]$body) {
  if ([string]::IsNullOrWhiteSpace($body)) { return @{Kind='EMPTY'} }
  $j = $null
  try { $j = $body | ConvertFrom-Json } catch { return @{Kind='NONJSON'} }
  if ($j -and $j.errors) { return @{Kind='ERROR'; Code=$j.errors[0].status; Details=$j.errors[0].details} }
  $st = $null
  if ($j.data -and $j.data.attributes -and $j.data.attributes.status) { $st = $j.data.attributes.status }
  elseif ($j.attributes -and $j.attributes.status) { $st = $j.attributes.status }
  elseif ($j.status) { $st = $j.status }
  return @{Kind='OK'; Status=$st; Json=$j}
}

function Ensure-Dir([string]$p) { if (-not (Test-Path -LiteralPath $p)) { $null = New-Item -ItemType Directory -Path $p -Force } }

# ---------- scope & headers ----------
$scopeNoRest = if ($PSCmdlet.ParameterSetName -eq 'Org') { "/orgs/$OrgId" } else { "/groups/$GroupId" }
$restScope   = "/rest$($scopeNoRest)"

$headers = @{
  Authorization     = "token $Token"
  Accept            = "application/vnd.api+json"
  "Accept-Encoding" = "identity"   # avoid gzip weirdness in PS 5.1
  "Cache-Control"   = "no-cache"
}

# ---------- fail fast on region/permission ----------
Test-SnykScopeAccess -Url "$BaseUrl/rest/user/me?version=$Version" -Headers $headers
Test-SnykScopeAccess -Url "$BaseUrl$restScope?version=$Version"    -Headers $headers

# ---------- start export ----------
$uFrom = New-JsonTime $UpdatedFrom
$uTo   = New-JsonTime $UpdatedTo

$body = @{
  data = @{
    type = "resource"
    attributes = @{
      dataset = $Dataset
      formats = @("csv")
      filters = @{ updated = @{ from = $uFrom; to = $uTo } }
    }
  }
} | ConvertTo-Json -Depth 20

$startUri = "$BaseUrl$restScope/export?version=$Version"
Write-Host "Starting export: $startUri" -ForegroundColor Cyan

try {
  $startResp = Invoke-WebRequest -Method POST -Uri $startUri -Headers $headers `
               -Body $body -ContentType "application/vnd.api+json" -UseBasicParsing -ErrorAction Stop
} catch { throw "Export start failed: $($_.Exception.Message)" }

if (-not $startResp.Content) { throw "Start export returned empty body." }

# PS 5.1: ConvertFrom-Json has no -Depth â€” do NOT pass one
$startJson = $startResp.Content | ConvertFrom-Json
$exportId  = $startJson.data.id
if (-not $exportId) { throw "Could not read data.id from start response:`n$($startResp.Content)" }

# canonical URLs (ignore any link; use id)
$statusUri  = "$BaseUrl$restScope/jobs/export/$exportId?version=$Version"
$resultsUri = "$BaseUrl$restScope/export/$exportId?version=$Version"

Write-Host "Job ID: $exportId" -ForegroundColor DarkCyan
Write-Host "Polling: $statusUri"

# ---------- poll ----------
$deadline = (Get-Date).AddMinutes($TimeoutMinutes)
$status = $null

do {
  Start-Sleep -Seconds $PollSeconds

  try {
    $poll = Invoke-WebRequest -Method GET -Uri $statusUri -Headers $headers -UseBasicParsing -ErrorAction Stop
  } catch {
    $m = $_.Exception.Message
    if ($m -match '401') { throw "401 Unauthorized polling status. Token needs 'View reports' on this scope." }
    if ($m -match '404') { throw "404 Not Found polling status. Check region ($BaseUrl) and OrgId/GroupId." }
    throw "Status check failed: $m"
  }

  $parsed = Parse-Status ([string]$poll.Content)
  switch ($parsed.Kind) {
    'ERROR'   { throw "Snyk API error during poll: $($parsed.Code) $($parsed.Details)" }
    'EMPTY'   { $status = 'IN_PROGRESS' }
    'NONJSON' { $status = 'IN_PROGRESS' }
    'OK'      {
      $status = $parsed.Status; if (-not $status) { $status = 'IN_PROGRESS' }
      Write-Host ("Status: {0} (HTTP {1})" -f $status, $poll.StatusCode)
      if ($status -in @('FAILED','ERROR','CANCELLED')) {
        $err = $parsed.Json.data.attributes.errors
        throw ("Export job reported $status. " + ($err | ConvertTo-Json -Depth 20))
      }
    }
  }
} while ($status -ne 'FINISHED' -and (Get-Date) -lt $deadline)

if ($status -ne 'FINISHED') { throw "Timed out after $TimeoutMinutes minutes waiting for job $exportId." }

# ---------- results ----------
try {
  $res = Invoke-RestMethod -Method GET -Uri $resultsUri -Headers $headers -ErrorAction Stop
} catch {
  $m = $_.Exception.Message
  if ($m -match '401') { throw "401 Unauthorized fetching results. Token needs 'View reports' on this scope." }
  if ($m -match '404') { throw "404 Not Found fetching results. Check region/IDs." }
  throw "Fetching results failed: $m"
}

$items = $res.data.attributes.results
if (-not $items -or $items.Count -eq 0) { Write-Warning "Finished, but results list was empty."; return }

# ---------- download ----------
Ensure-Dir $OutDir
$files = @()
foreach ($it in $items) {
  $url  = $it.location; if (-not $url) { $url = $it.url }
  if (-not $url -and $it.links -and $it.links.download) { $url = $it.links.download }
  if (-not $url) { Write-Warning "Unknown result shape:`n$($it | ConvertTo-Json -Depth 20)"; continue }

  $name = $it.file_name
  if (-not $name) { try { $name = ([Uri]$url).Segments[-1] } catch { $name = "export-$exportId-$(Get-Random).csv" } }

  $target = Join-Path $OutDir $name
  Write-Host "Downloading $name ..."
  Invoke-WebRequest -Uri $url -OutFile $target -UseBasicParsing -ErrorAction Stop
  $files += $target
}

Write-Host "`nDownloaded:" -ForegroundColor Green
$files | ForEach-Object { Write-Host " - $_" }

Write-Host "`nDone." -ForegroundColor Green
