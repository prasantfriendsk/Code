# Snyk Data Extractor - Final Working Version
# Uses the confirmed working API endpoint with additional URL patterns

param(
    [Parameter(Mandatory=$true)]
    [string]$ApiToken,
    
    [Parameter(Mandatory=$false)]
    [string]$OrgId = "bfaad577-6f5a-4a81-ad27-ec2113e72731",  # Default to Thrivent org
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "."
)

# Working API base URL (confirmed from your test)
$BaseUrl = "https://api.snyk.io/v1"

# Headers
$Headers = @{
    "Authorization" = "token $ApiToken"
    "Content-Type" = "application/json"
}

# Function to try multiple URL patterns for projects
function Get-ProjectsAllPatterns {
    param([string]$OrganizationId)
    
    Write-Host "Trying multiple URL patterns for projects..." -ForegroundColor Yellow
    
    # Different URL patterns to try
    $urlPatterns = @(
        "$BaseUrl/org/$OrganizationId/projects",
        "$BaseUrl/orgs/$OrganizationId/projects", 
        "$BaseUrl/organizations/$OrganizationId/projects",
        "$BaseUrl/org/$OrganizationId/project",
        "$BaseUrl/v1/org/$OrganizationId/projects",
        "$BaseUrl/reporting/org/$OrganizationId/projects"
    )
    
    $allProjects = @()
    
    foreach ($url in $urlPatterns) {
        try {
            Write-Host "  Trying: $url" -ForegroundColor Gray
            $response = Invoke-RestMethod -Uri $url -Headers $Headers -Method GET -TimeoutSec 15
            
            if ($response.projects) {
                Write-Host "  ✓ SUCCESS! Found $($response.projects.Count) projects" -ForegroundColor Green
                foreach ($project in $response.projects) {
                    $allProjects += [PSCustomObject]@{
                        id = $project.id
                        name = $project.name
                        origin = $project.origin
                        type = $project.type
                        created = $project.created
                        isMonitored = $project.isMonitored
                        totalDependencies = $project.totalDependencies
                        issueCountsBySeverity = $project.issueCountsBySeverity
                        remoteRepoUrl = $project.remoteRepoUrl
                        lastTestedDate = $project.lastTestedDate
                        browseUrl = $project.browseUrl
                        targetFile = $project.targetFile
                        targetReference = $project.targetReference
                    }
                }
                break  # Success, no need to try other patterns
            } elseif ($response.data) {
                # Handle different response structure
                Write-Host "  ✓ SUCCESS! Found $($response.data.Count) projects (alternate structure)" -ForegroundColor Green
                foreach ($project in $response.data) {
                    $allProjects += [PSCustomObject]@{
                        id = $project.id
                        name = if ($project.attributes) { $project.attributes.name } else { $project.name }
                        origin = if ($project.attributes) { $project.attributes.origin } else { $project.origin }
                        type = if ($project.attributes) { $project.attributes.type } else { $project.type }
                        created = if ($project.attributes) { $project.attributes.created } else { $project.created }
                        isMonitored = $true
                        totalDependencies = 0
                        issueCountsBySeverity = @{}
                        remoteRepoUrl = ""
                        lastTestedDate = ""
                        browseUrl = ""
                        targetFile = if ($project.attributes) { $project.attributes.targetFile } else { $project.targetFile }
                        targetReference = if ($project.attributes) { $project.attributes.targetReference } else { $project.targetReference }
                    }
                }
                break
            }
            
        } catch {
            $statusCode = $_.Exception.Response.StatusCode.value__ -as [int]
            Write-Host "    Failed ($statusCode): $($_.Exception.Message)" -ForegroundColor Red
            continue
        }
    }
    
    return $allProjects
}

# Function to get issues with multiple patterns
function Get-IssuesAllPatterns {
    param([string]$OrganizationId, [array]$Projects)
    
    if ($Projects.Count -eq 0) {
        Write-Warning "No projects available for issue extraction"
        return @()
    }
    
    Write-Host "Trying to get issues for $($Projects.Count) projects..." -ForegroundColor Yellow
    
    # Try organization-level issues first
    $orgLevelPatterns = @(
        "$BaseUrl/org/$OrganizationId/issues",
        "$BaseUrl/orgs/$OrganizationId/issues",
        "$BaseUrl/reporting/org/$OrganizationId/issues"
    )
    
    $allIssues = @()
    $foundOrgLevel = $false
    
    foreach ($url in $orgLevelPatterns) {
        try {
            Write-Host "  Trying org-level issues: $url" -ForegroundColor Gray
            
            # For org-level issues, try POST with filters
            $body = @{
                "filters" = @{
                    "severities" = @("high", "medium", "low", "critical")
                    "types" = @("vuln", "license")
                }
            } | ConvertTo-Json -Depth 5
            
            $response = Invoke-RestMethod -Uri $url -Headers $Headers -Method POST -Body $body -TimeoutSec 30
            
            if ($response.issues) {
                Write-Host "  ✓ SUCCESS! Found $($response.issues.Count) org-level issues" -ForegroundColor Green
                foreach ($issue in $response.issues) {
                    $allIssues += [PSCustomObject]@{
                        id = $issue.id
                        title = $issue.title
                        type = $issue.type
                        severity = $issue.severity
                        package = $issue.package
                        version = $issue.version
                        language = $issue.language
                        packageManager = $issue.packageManager
                        isPatchable = $issue.isPatchable
                        isUpgradable = $issue.isUpgradable
                        cvssScore = $issue.cvssScore
                        cvssVector = $issue.CVSSv3
                        disclosureTime = $issue.disclosureTime
                        publicationTime = $issue.publicationTime
                        introducedDate = $issue.introducedDate
                        fixedIn = ($issue.fixedIn -join "; ")
                        upgradePath = if ($issue.upgradePath) { ($issue.upgradePath -join " -> ") } else { "" }
                        credit = ($issue.credit -join "; ")
                        projectId = $issue.projectId
                        projectName = $issue.projectName
                        method = "org-level"
                    }
                }
                $foundOrgLevel = $true
                break
            }
        } catch {
            Write-Host "    Failed: $($_.Exception.Message)" -ForegroundColor Red
            continue
        }
    }
    
    # If org-level didn't work, try project-level
    if (-not $foundOrgLevel) {
        Write-Host "  Org-level failed, trying project-level issues..." -ForegroundColor Yellow
        
        $projectCount = 0
        $maxProjects = [Math]::Min(20, $Projects.Count)  # Limit to avoid timeout
        
        foreach ($project in $Projects[0..($maxProjects-1)]) {
            $projectCount++
            Write-Host "    Project $projectCount/$maxProjects : $($project.name)" -ForegroundColor Green
            
            $projectUrlPatterns = @(
                "$BaseUrl/org/$OrganizationId/project/$($project.id)/issues",
                "$BaseUrl/orgs/$OrganizationId/projects/$($project.id)/issues",
                "$BaseUrl/org/$OrganizationId/projects/$($project.id)/issues"
            )
            
            foreach ($projectUrl in $projectUrlPatterns) {
                try {
                    $response = Invoke-RestMethod -Uri $projectUrl -Headers $Headers -Method GET -TimeoutSec 15
                    
                    if ($response.issues) {
                        Write-Host "      Found $($response.issues.Count) issues" -ForegroundColor White
                        foreach ($issue in $response.issues) {
                            $allIssues += [PSCustomObject]@{
                                id = $issue.id
                                title = $issue.title
                                type = $issue.type
                                severity = $issue.severity
                                package = $issue.package
                                version = $issue.version
                                language = $issue.language
                                packageManager = $issue.packageManager
                                isPatchable = $issue.isPatchable
                                isUpgradable = $issue.isUpgradable
                                cvssScore = $issue.cvssScore
                                cvssVector = $issue.CVSSv3
                                disclosureTime = $issue.disclosureTime
                                publicationTime = $issue.publicationTime
                                introducedDate = $issue.introducedDate
                                fixedIn = ($issue.fixedIn -join "; ")
                                upgradePath = if ($issue.upgradePath) { ($issue.upgradePath -join " -> ") } else { "" }
                                credit = ($issue.credit -join "; ")
                                projectId = $project.id
                                projectName = $project.name
                                method = "project-level"
                            }
                        }
                        break  # Success for this project
                    }
                } catch {
                    continue  # Try next URL pattern
                }
            }
            
            Start-Sleep -Milliseconds 200  # Rate limiting
        }
    }
    
    return $allIssues
}

# Function to save to CSV
function Save-ToCSV {
    param([array]$Data, [string]$FileName)
    
    if ($Data.Count -eq 0) {
        Write-Warning "No data to save for $FileName"
        return
    }
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $filePath = Join-Path $OutputPath "$FileName`_$timestamp.csv"
    
    try {
        $Data | Export-Csv -Path $filePath -NoTypeInformation -Encoding UTF8
        Write-Host "✓ Saved $($Data.Count) records to: $filePath" -ForegroundColor Green
        
        # Show first few records as preview
        Write-Host "Preview of saved data:" -ForegroundColor Cyan
        $Data | Select-Object -First 3 | Format-Table -AutoSize | Out-String | Write-Host
        
    } catch {
        Write-Error "Failed to save CSV: $($_.Exception.Message)"
    }
}

# Main execution
Write-Host "=== Snyk Data Extractor - Thrivent Organization ===" -ForegroundColor Cyan
Write-Host "Organization: Thrivent ($OrgId)" -ForegroundColor Green
Write-Host "API Endpoint: $BaseUrl" -ForegroundColor Green
Write-Host "Output Path: $OutputPath" -ForegroundColor Green

# Create output directory
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# Extract Projects
Write-Host "`n--- Extracting Projects ---" -ForegroundColor Magenta
$projects = Get-ProjectsAllPatterns -OrganizationId $OrgId

if ($projects.Count -gt 0) {
    Write-Host "Successfully found $($projects.Count) projects!" -ForegroundColor Green
    Save-ToCSV -Data $projects -FileName "snyk_projects"
    
    # Extract Issues
    Write-Host "`n--- Extracting Issues ---" -ForegroundColor Magenta
    $issues = Get-IssuesAllPatterns -OrganizationId $OrgId -Projects $projects
    
    if ($issues.Count -gt 0) {
        Write-Host "Successfully found $($issues.Count) issues!" -ForegroundColor Green
        Save-ToCSV -Data $issues -FileName "snyk_issues"
    } else {
        Write-Warning "No issues found using any method"
    }
    
} else {
    Write-Error "No projects found using any URL pattern"
    Write-Host "`nPossible reasons:" -ForegroundColor Yellow
    Write-Host "1. Organization has no projects" -ForegroundColor White
    Write-Host "2. API token doesn't have project access" -ForegroundColor White  
    Write-Host "3. Different API endpoint needed" -ForegroundColor White
    Write-Host "4. Projects are in a different organization" -ForegroundColor White
}

Write-Host "`n=== Final Summary ===" -ForegroundColor Cyan
Write-Host "Projects extracted: $($projects.Count)" -ForegroundColor $(if($projects.Count -gt 0){"Green"}else{"Red"})
Write-Host "Issues extracted: $(if($issues){$issues.Count}else{0})" -ForegroundColor $(if($issues -and $issues.Count -gt 0){"Green"}else{"Red"})
Write-Host "Files created in: $OutputPath" -ForegroundColor Green
