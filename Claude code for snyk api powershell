# Snyk Data Extractor - Updated for Current API
# Uses Snyk REST API (2021-06-04 version) and legacy endpoints where needed

param(
    [Parameter(Mandatory=$true)]
    [string]$ApiToken,
    
    [Parameter(Mandatory=$false)]
    [string]$OrgId,
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "."
)

# API URLs - Using different versions for different endpoints
$LegacyBaseUrl = "https://snyk.io/api/v1"
$RestBaseUrl = "https://api.snyk.io/rest"
$ApiVersion = "2021-06-04"

# Headers for different API versions
$LegacyHeaders = @{
    "Authorization" = "token $ApiToken"
    "Content-Type" = "application/json"
}

$RestHeaders = @{
    "Authorization" = "token $ApiToken"
    "Content-Type" = "application/vnd.api+json"
}

# Function to test API connectivity
function Test-SnykAPI {
    try {
        Write-Host "Testing API connectivity..." -ForegroundColor Yellow
        # Test with legacy API first
        $response = Invoke-RestMethod -Uri "$LegacyBaseUrl/user/me" -Headers $LegacyHeaders -Method GET
        Write-Host "Legacy API connection successful. User: $($response.username)" -ForegroundColor Green
        return $true
    } catch {
        Write-Warning "Legacy API test failed: $($_.Exception.Message)"
        
        # Try with REST API
        try {
            $response = Invoke-RestMethod -Uri "$RestBaseUrl/orgs?version=$ApiVersion" -Headers $RestHeaders -Method GET
            Write-Host "REST API connection successful" -ForegroundColor Green
            return $true
        } catch {
            Write-Error "Both API versions failed: $($_.Exception.Message)"
            return $false
        }
    }
}

# Function to get organizations using REST API
function Get-Organizations {
    try {
        Write-Host "Retrieving organizations..." -ForegroundColor Yellow
        
        # Try REST API first
        try {
            $url = "$RestBaseUrl/orgs?version=$ApiVersion&limit=100"
            $response = Invoke-RestMethod -Uri $url -Headers $RestHeaders -Method GET
            
            if ($response.data -and $response.data.Count -gt 0) {
                Write-Host "Found $($response.data.Count) organization(s) via REST API:" -ForegroundColor Green
                $orgs = @()
                foreach ($org in $response.data) {
                    $orgs += [PSCustomObject]@{
                        id = $org.id
                        name = $org.attributes.name
                        slug = $org.attributes.slug
                    }
                    Write-Host "  - $($org.attributes.name) (ID: $($org.id))" -ForegroundColor White
                }
                return $orgs
            }
        } catch {
            Write-Warning "REST API failed, trying legacy API: $($_.Exception.Message)"
        }
        
        # Fallback to legacy API
        $response = Invoke-RestMethod -Uri "$LegacyBaseUrl/orgs" -Headers $LegacyHeaders -Method GET
        
        if ($response.orgs -and $response.orgs.Count -gt 0) {
            Write-Host "Found $($response.orgs.Count) organization(s) via Legacy API:" -ForegroundColor Green
            foreach ($org in $response.orgs) {
                Write-Host "  - $($org.name) (ID: $($org.id))" -ForegroundColor White
            }
            return $response.orgs
        } else {
            Write-Warning "No organizations found"
            return @()
        }
    } catch {
        Write-Error "Failed to retrieve organizations: $($_.Exception.Message)"
        return @()
    }
}

# Function to get projects using REST API with pagination
function Get-AllProjects {
    param([string]$OrganizationId)
    
    Write-Host "Retrieving projects for organization: $OrganizationId" -ForegroundColor Yellow
    
    $allProjects = @()
    $nextUrl = "$RestBaseUrl/orgs/$OrganizationId/projects?version=$ApiVersion&limit=100"
    $pageNum = 1
    
    do {
        try {
            Write-Host "Fetching projects page $pageNum..." -ForegroundColor Green
            $response = Invoke-RestMethod -Uri $nextUrl -Headers $RestHeaders -Method GET
            
            if ($response.data) {
                foreach ($project in $response.data) {
                    $projectObj = [PSCustomObject]@{
                        id = $project.id
                        name = $project.attributes.name
                        origin = $project.attributes.origin
                        type = $project.attributes.type
                        created = $project.attributes.created
                        status = $project.attributes.status
                        targetFile = $project.attributes.target_file
                        targetReference = $project.attributes.target_reference
                        tags = ($project.attributes.tags | ConvertTo-Json -Compress)
                    }
                    $allProjects += $projectObj
                }
                
                Write-Host "Page $pageNum : Retrieved $($response.data.Count) projects" -ForegroundColor Green
                
                # Check for next page
                $nextUrl = $null
                if ($response.links -and $response.links.next) {
                    $nextUrl = $response.links.next
                    $pageNum++
                } elseif ($response.data.Count -eq 100) {
                    # Manual pagination if links not provided
                    $nextUrl = "$RestBaseUrl/orgs/$OrganizationId/projects?version=$ApiVersion&limit=100&starting_after=$($response.data[-1].id)"
                    $pageNum++
                }
            } else {
                break
            }
            
            Start-Sleep -Milliseconds 500  # Rate limiting
            
        } catch {
            Write-Warning "Error fetching projects page $pageNum : $($_.Exception.Message)"
            
            # Try legacy API as fallback
            if ($pageNum -eq 1) {
                Write-Host "Trying legacy API for projects..." -ForegroundColor Yellow
                try {
                    $legacyUrl = "$LegacyBaseUrl/org/$OrganizationId/projects"
                    $legacyResponse = Invoke-RestMethod -Uri $legacyUrl -Headers $LegacyHeaders -Method GET
                    
                    if ($legacyResponse.projects) {
                        foreach ($project in $legacyResponse.projects) {
                            $projectObj = [PSCustomObject]@{
                                id = $project.id
                                name = $project.name
                                origin = $project.origin
                                type = $project.type
                                created = $project.created
                                status = "active"
                                targetFile = $project.targetFile
                                targetReference = $project.targetReference
                                tags = ""
                            }
                            $allProjects += $projectObj
                        }
                        Write-Host "Legacy API: Retrieved $($legacyResponse.projects.Count) projects" -ForegroundColor Green
                    }
                } catch {
                    Write-Error "Legacy API also failed: $($_.Exception.Message)"
                }
            }
            break
        }
        
    } while ($nextUrl)
    
    Write-Host "Total projects retrieved: $($allProjects.Count)" -ForegroundColor Green
    return $allProjects
}

# Function to get issues using REST API
function Get-AllIssues {
    param(
        [string]$OrganizationId,
        [array]$Projects
    )
    
    Write-Host "Retrieving issues for organization: $OrganizationId" -ForegroundColor Yellow
    
    $allIssues = @()
    
    # Try to get issues at org level first
    try {
        $url = "$RestBaseUrl/orgs/$OrganizationId/issues?version=$ApiVersion&limit=1000"
        Write-Host "Attempting to retrieve issues at organization level..." -ForegroundColor Green
        
        $response = Invoke-RestMethod -Uri $url -Headers $RestHeaders -Method GET
        
        if ($response.data) {
            foreach ($issue in $response.data) {
                $issueObj = [PSCustomObject]@{
                    id = $issue.id
                    title = $issue.attributes.title
                    type = $issue.attributes.type
                    severity = $issue.attributes.effective_severity_level
                    status = $issue.attributes.status
                    priority = $issue.attributes.priority_score
                    created = $issue.attributes.created_at
                    updated = $issue.attributes.updated_at
                    package_name = if ($issue.attributes.slots) { $issue.attributes.slots.package } else { "" }
                    package_version = if ($issue.attributes.slots) { $issue.attributes.slots.version } else { "" }
                    project_id = if ($issue.relationships -and $issue.relationships.scan_item) { $issue.relationships.scan_item.data.id } else { "" }
                }
                $allIssues += $issueObj
            }
            Write-Host "Retrieved $($response.data.Count) issues from organization level" -ForegroundColor Green
        }
        
    } catch {
        Write-Warning "Organization-level issues failed: $($_.Exception.Message)"
        
        # Fallback to project-level issue retrieval using legacy API
        Write-Host "Falling back to project-level issue retrieval..." -ForegroundColor Yellow
        
        $projectCount = 0
        foreach ($project in $Projects) {
            $projectCount++
            Write-Host "Processing project $projectCount/$($Projects.Count): $($project.name)" -ForegroundColor Green
            
            try {
                $url = "$LegacyBaseUrl/org/$OrganizationId/project/$($project.id)/issues"
                $response = Invoke-RestMethod -Uri $url -Headers $LegacyHeaders -Method GET
                
                if ($response.issues) {
                    foreach ($issue in $response.issues) {
                        $issueObj = [PSCustomObject]@{
                            id = $issue.id
                            title = $issue.title
                            type = $issue.type
                            severity = $issue.severity
                            status = "open"
                            priority = $issue.priorityScore
                            created = $issue.introducedDate
                            updated = $issue.modificationTime
                            package_name = $issue.package
                            package_version = $issue.version
                            project_id = $project.id
                            project_name = $project.name
                            project_origin = $project.origin
                            project_type = $project.type
                            is_patchable = $issue.isPatchable
                            is_upgradable = $issue.isUpgradable
                            cvss_score = $issue.cvssScore
                            fixed_in = ($issue.fixedIn -join "; ")
                        }
                        $allIssues += $issueObj
                    }
                    Write-Host "  Found $($response.issues.Count) issues" -ForegroundColor White
                } else {
                    Write-Host "  No issues found" -ForegroundColor Gray
                }
                
                Start-Sleep -Milliseconds 300  # Rate limiting
                
            } catch {
                Write-Warning "Error fetching issues for project $($project.name): $($_.Exception.Message)"
                continue
            }
        }
    }
    
    Write-Host "Total issues retrieved: $($allIssues.Count)" -ForegroundColor Green
    return $allIssues
}

# Function to save data to CSV
function Save-ToCSV {
    param(
        [array]$Data,
        [string]$FileName
    )
    
    if ($Data.Count -eq 0) {
        Write-Warning "No data to save for $FileName"
        return
    }
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $filePath = Join-Path $OutputPath "$FileName`_$timestamp.csv"
    
    try {
        $Data | Export-Csv -Path $filePath -NoTypeInformation -Encoding UTF8
        Write-Host "Saved $($Data.Count) records to: $filePath" -ForegroundColor Green
    } catch {
        Write-Error "Failed to save CSV: $($_.Exception.Message)"
    }
}

# Main execution
Write-Host "=== Snyk Data Extractor (Updated API) ===" -ForegroundColor Cyan

# Test API connectivity first
if (-not (Test-SnykAPI)) {
    Write-Error "Cannot connect to Snyk API. Please check your token."
    exit 1
}

# Get organizations
$orgs = Get-Organizations
if ($orgs.Count -eq 0) {
    Write-Error "No organizations found"
    exit 1
}

# Determine organization to use
if (-not $OrgId) {
    if ($orgs.Count -eq 1) {
        $OrgId = $orgs[0].id
        Write-Host "Using organization: $($orgs[0].name)" -ForegroundColor Green
    } else {
        Write-Host "Multiple organizations available. Please specify -OrgId parameter:" -ForegroundColor Yellow
        foreach ($org in $orgs) {
            Write-Host "  Use: -OrgId '$($org.id)' for '$($org.name)'" -ForegroundColor White
        }
        exit 1
    }
} else {
    # Verify the provided OrgId exists
    $selectedOrg = $orgs | Where-Object { $_.id -eq $OrgId }
    if (-not $selectedOrg) {
        Write-Error "Organization ID '$OrgId' not found. Available IDs: $($orgs.id -join ', ')"
        exit 1
    }
    Write-Host "Using specified organization: $($selectedOrg.name)" -ForegroundColor Green
}

# Create output directory
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

Write-Host "`nOrganization ID: $OrgId" -ForegroundColor Cyan
Write-Host "Output Path: $OutputPath" -ForegroundColor Cyan

# Extract Projects
Write-Host "`n--- Extracting Projects ---" -ForegroundColor Magenta
$projects = Get-AllProjects -OrganizationId $OrgId

if ($projects.Count -gt 0) {
    Save-ToCSV -Data $projects -FileName "snyk_projects"
    
    # Extract Issues
    Write-Host "`n--- Extracting Issues ---" -ForegroundColor Magenta
    $issues = Get-AllIssues -OrganizationId $OrgId -Projects $projects
    
    if ($issues.Count -gt 0) {
        Save-ToCSV -Data $issues -FileName "snyk_issues"
    }
} else {
    Write-Warning "No projects found. Cannot extract issues."
}

Write-Host "`n=== Extraction Complete ===" -ForegroundColor Cyan
Write-Host "Projects: $($projects.Count)" -ForegroundColor Green
Write-Host "Issues: $(if($issues) {$issues.Count} else {0})" -ForegroundColor Green
