<# 
.SYNOPSIS
  Start a Snyk Export API job, wait for completion, download CSV(s), optionally combine.

.PARAMETER OrgId
  Snyk Org GUID (use either -OrgId or -GroupId).

.PARAMETER GroupId
  Snyk Group GUID (use either -GroupId or -OrgId).

.PARAMETER Token
  Snyk API token. Defaults to $env:SNYK_TOKEN.

.PARAMETER BaseUrl
  API base URL. Default https://api.snyk.io (US-01).
  Use https://api.us.snyk.io for US-02, https://api.eu.snyk.io for EU.

.PARAMETER Version
  REST API version for the initial request. Script will auto-align to whatever the server returns in the self link.

.PARAMETER Dataset
  Snyk export dataset: 'issues' or 'usage'. Default 'issues'.

.PARAMETER UpdatedFrom / UpdatedTo
  UTC window for 'updated' filter. Defaults to last 30 days.

.PARAMETER Columns
  Optional explicit column list. If omitted, Snyk uses its default schema.

.PARAMETER OutDir
  Directory to save downloaded files.

.PARAMETER Combine
  If set, merges all downloaded CSVs into a single CSV.

.PARAMETER CombinedOutFile
  Target filename when -Combine is used.

.EXAMPLE
  # Org export (US-01)
  .\Invoke-SnykExport.ps1 -OrgId "00000000-0000-0000-0000-000000000000" `
    -Token $env:SNYK_TOKEN -OutDir .\snyk-export

.EXAMPLE
  # Group export (US-02), last 7 days, combine CSVs
  .\Invoke-SnykExport.ps1 -GroupId "11111111-1111-1111-1111-111111111111" `
    -BaseUrl "https://api.us.snyk.io" -Token $env:SNYK_TOKEN `
    -UpdatedFrom (Get-Date).AddDays(-7) -Combine
#>

[CmdletBinding(DefaultParameterSetName='Org')]
param(
  [Parameter(Mandatory=$true, ParameterSetName='Org')]
  [string]$OrgId,

  [Parameter(Mandatory=$true, ParameterSetName='Group')]
  [string]$GroupId,

  [string]$Token = $env:SNYK_TOKEN,
  [string]$BaseUrl = "https://api.snyk.io",
  [string]$Version = "2024-10-15",

  [ValidateSet('issues','usage')]
  [string]$Dataset = "issues",

  [datetime]$UpdatedFrom = (Get-Date).AddDays(-30),
  [datetime]$UpdatedTo   = (Get-Date),

  [string[]]$Columns,

  [string]$OutDir = ".\snyk-export",
  [int]$PollSeconds = 5,
  [int]$TimeoutMinutes = 30,

  [switch]$Combine,
  [string]$CombinedOutFile = "export_combined.csv"
)

# --- Helpers (PowerShell 5.1-safe) -----------------------------------------
function Resolve-AbsoluteUrl {
  param([string]$Base, [string]$MaybeRelative)
  if ([string]::IsNullOrWhiteSpace($MaybeRelative)) { return $null }
  if ($MaybeRelative.StartsWith("http")) { return $MaybeRelative }
  if ($MaybeRelative.StartsWith("/"))   { return ($Base.TrimEnd('/') + $MaybeRelative) }
  # Fallback: treat as relative to base
  return ($Base.TrimEnd('/') + '/' + $MaybeRelative.TrimStart('/'))
}

function Extract-QueryVersion {
  param([string]$Url)
  if ([string]::IsNullOrWhiteSpace($Url)) { return $null }
  if ($Url -match '(?:\?|&)version=([^&]+)') { return $Matches[1] }
  return $null
}

function Extract-ExportId {
  param([string]$Url)
  if ([string]::IsNullOrWhiteSpace($Url)) { return $null }
  if ($Url -match '/jobs/export/([^/?]+)') { return $Matches[1] }
  return $null
}

function Ensure-Dir {
  param([string]$Path)
  if (-not (Test-Path -LiteralPath $Path)) { $null = New-Item -ItemType Directory -Path $Path -Force }
}

function Download-ResultFile {
  param([string]$Url, [string]$FileName, [string]$TargetDir)
  Ensure-Dir -Path $TargetDir
  $outFile = Join-Path $TargetDir $FileName
  Write-Host "Downloading $FileName ..."
  Invoke-WebRequest -Uri $Url -OutFile $outFile -ErrorAction Stop
  return $outFile
}

# --- Validate token ----------------------------------------------------------
if ([string]::IsNullOrWhiteSpace($Token)) {
  throw "Snyk API token not provided. Pass -Token or set $env:SNYK_TOKEN."
}

# --- Build scope & headers ---------------------------------------------------
$scopePath = if ($PSCmdlet.ParameterSetName -eq 'Org') { "/rest/orgs/$OrgId" } else { "/rest/groups/$GroupId" }

$headers = @{
  "Authorization" = "token $Token"
  "Content-Type"  = "application/vnd.api+json"
  "Accept"        = "application/json"
}

# --- Build request body (only send Columns if provided) ----------------------
$uFrom = $UpdatedFrom.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
$uTo   = $UpdatedTo.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")

$attrs = @{
  dataset = $Dataset
  formats = @("csv")
  filters = @{
    updated = @{
      from = $uFrom
      to   = $uTo
    }
  }
}
if ($PSBoundParameters.ContainsKey('Columns') -and $Columns -and $Columns.Count -gt 0) {
  $attrs.columns = $Columns
}

$bodyObj = @{ data = @{ type = "resource"; attributes = $attrs } }
$bodyJson = $bodyObj | ConvertTo-Json -Depth 10

# --- Start export ------------------------------------------------------------
$startUri = "$BaseUrl$scopePath/export?version=$Version"
Write-Host "Starting Snyk export ($Dataset) at $startUri" -ForegroundColor Cyan

$responseHeaders = $null
try {
  $startResp = Invoke-RestMethod -Method POST -Uri $startUri -Headers $headers -Body $bodyJson `
               -ResponseHeadersVariable responseHeaders -ErrorAction Stop
} catch {
  $msg = $_.ErrorDetails?.Message
  if (-not $msg) { $msg = $_.Exception.Message }
  throw "Export start failed: $msg"
}

# Prefer body.data.links.self; then headers.Location; then body.links.self; then body.data.id
$jobLink = $null
if ($startResp -and $startResp.data -and $startResp.data.links -and $startResp.data.links.self) {
  $jobLink = $startResp.data.links.self
} elseif ($responseHeaders -and $responseHeaders.Location) {
  $jobLink = $responseHeaders.Location
} elseif ($startResp -and $startResp.links -and $startResp.links.self) {
  $jobLink = $startResp.links.self
} elseif ($startResp -and $startResp.data -and $startResp.data.id) {
  $jobLink = "/$($scopePath.TrimStart('/'))/jobs/export/$($startResp.data.id)?version=$Version"
}

if (-not $jobLink) {
  throw "Unexpected export start response; couldn't find job link. Body:`n$($startResp | ConvertTo-Json -Depth 10)"
}

# Normalize to absolute URL
$jobLink = Resolve-AbsoluteUrl -Base $BaseUrl -MaybeRelative $jobLink

# Align Version with whatever the API returned in the link (e.g., 2025-08-01)
$versionFromLink = Extract-QueryVersion -Url $jobLink
if ($versionFromLink) { $Version = $versionFromLink }

# Parse exportId from job link
$exportId = Extract-ExportId -Url $jobLink
if (-not $exportId) {
  throw "Couldn't parse export id from: $jobLink"
}

# Build poll/result URLs with the aligned Version
$statusUri  = "$BaseUrl$scopePath/jobs/export/$exportId?version=$Version"
$resultsUri = "$BaseUrl$scopePath/export/$exportId?version=$Version"
Write-Host "Job: $exportId (version $Version)" -ForegroundColor DarkCyan

# --- Poll status -------------------------------------------------------------
$deadline = (Get-Date).AddMinutes($TimeoutMinutes)
$status = $null
do {
  Start-Sleep -Seconds $PollSeconds
  try {
    $statusResp = Invoke-RestMethod -Method GET -Uri $statusUri -Headers $headers -ErrorAction Stop
  } catch {
    $msg = $_.ErrorDetails?.Message
    if (-not $msg) { $msg = $_.Exception.Message }
    throw "Status check failed: $msg"
  }
  $status = $statusResp.data.attributes.status
  Write-Host "Status: $status"
  if ($status -eq 'FAILED' -or $status -eq 'ERROR') {
    $err = $statusResp.data.attributes.errors
    throw ("Export job failed. Details: " + ($err | ConvertTo-Json -Depth 10))
  }
} while ($status -ne 'FINISHED' -and (Get-Date) -lt $deadline)

if ($status -ne 'FINISHED') {
  throw "Timed out after $TimeoutMinutes minutes waiting for export job $exportId."
}

# --- Get results & download --------------------------------------------------
try {
  $resultsResp = Invoke-RestMethod -Method GET -Uri $resultsUri -Headers $headers -ErrorAction Stop
} catch {
  $msg = $_.ErrorDetails?.Message
  if (-not $msg) { $msg = $_.Exception.Message }
  throw "Fetching results failed: $msg"
}

$items = $resultsResp.data.attributes.results
if (-not $items -or $items.Count -eq 0) {
  Write-Warning "Export finished but 'results' is empty."
  return
}

Ensure-Dir -Path $OutDir
$downloaded = @()

foreach ($item in $items) {
  # Try common URL/filename shapes
  $url = $null
  if ($item.PSObject.Properties.Name -contains 'location') { $url = $item.location }
  if (-not $url -and $item.PSObject.Properties.Name -contains 'url') { $url = $item.url }
  if (-not $url -and $item.links -and $item.links.download) { $url = $item.links.download }

  if (-not $url) {
    Write-Warning "Unknown results schema:`n$($item | ConvertTo-Json -Depth 10)"
    continue
  }

  $name = $null
  if ($item.PSObject.Properties.Name -contains 'file_name') { $name = $item.file_name }
  if (-not $name) {
    try { $name = ([Uri]$url).Segments[-1] } catch { $name = "export-$exportId-$([guid]::NewGuid().Guid).csv" }
  }

  $absUrl = Resolve-AbsoluteUrl -Base $BaseUrl -MaybeRelative $url
  $downloaded += (Download-ResultFile -Url $absUrl -FileName $name -TargetDir $OutDir)
}

Write-Host "`nDownloaded files:" -ForegroundColor Green
$downloaded | ForEach-Object { Write-Host " - $_" }

# --- Optional: combine into one CSV -----------------------------------------
if ($Combine -and $downloaded.Count -gt 0) {
  Write-Host "`nCombining CSVs into $CombinedOutFile ..." -ForegroundColor Cyan

  $allHeaders = New-Object System.Collections.Generic.HashSet[string]
  foreach ($f in $downloaded) {
    try {
      $firstLine = (Get-Content -LiteralPath $f -TotalCount 1)
      if ($firstLine) {
        $cols = $firstLine -split ',(?=(?:[^"]*"[^"]*")*[^"]*$)'
        foreach ($c in $cols) { [void]$allHeaders.Add($c.Trim('"')) }
      }
    } catch { }
  }

  $headerArray = @($allHeaders)
  if ($headerArray.Count -eq 0) {
    Write-Warning "Could not detect headers; skipping combine."
  } else {
    $combined = New-Object System.Collections.Generic.List[object]
    foreach ($f in $downloaded) {
      try {
        $rows = Import-Csv -LiteralPath $f
        if ($rows) {
          # Normalize columns across files
          foreach ($r in $rows) {
            $obj = New-Object PSObject
            foreach ($h in $headerArray) {
              $null = Add-Member -InputObject $obj -MemberType NoteProperty -Name $h -Value ($r.$h) -Force
            }
            $combined.Add($obj) | Out-Null
          }
        }
      } catch {
        Write-Warning "Failed to read $f: $($_.Exception.Message)"
      }
    }

    $combinedPath = Join-Path $OutDir $CombinedOutFile
    $combined | Export-Csv -LiteralPath $combinedPath -NoTypeInformation
    Write-Host "Combined CSV written: $combinedPath" -ForegroundColor Green
  }
}

Write-Host "`nDone." -ForegroundColor Green
